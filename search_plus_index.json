{"./":{"url":"./","title":"Introduction","keywords":"","body":" 概览 / Overview jskyzero 2020/08/04 本博客为 jskyzero 所建，用来分享编程与计算机科学相关的内容。 otaku.change(world); // by jskyzero 结构 / Structure + 0.博客介绍 // 基础情况的介绍 + 1.编程语言 // 编程语言的语法、最佳实践 + 2.软件工具 // 辅助工具的使用、参考 + 3.计算机科学 // 学科相关 + 专题-UNITY // UNITY与游戏开发 + 专题-UWP // WINDOWS与UWP 更新日志 2020/08/04 Update：使用gitbook重新整理了博客。 2019/08/01 Update：准备将一些放弃的梦想整理出来。 2019/04/22 Update：重新分析应该把内容放在哪里。 README: 项目的简短介绍 GitHub Wiki：项目内相关的介绍 Blog：专题的概览介绍 2019/01/03 Update：重新整理了已經有的文章。 2018/11/11 Update：更新到了原來某個簡介美觀的主題。 2018/10/13 Update：將頁面黑白化。 2018/07/04 Update：本博客定位变成 Notes，各种需要记录下来的事情。 Program，编程与计算机相关的总结。 Books & Items，读书报告和物件。 2018/05/09 Update：对文章目录进行了分类。 2017/05/04 Update：计划移除ACGN/个人生活相关的内容 2017/02/16 Update：想要多添加一些tag 2017/02/09 Update：将之前的一些内容薄弱的随笔进行了整合，有些“post”的内容根本不能被称为一篇文章。 2017/02/02 Update：关于建立该博客的原因： Because I can. 想要确实的记录点什么，知识也好，感触也罢。 2016/12/30：会把很多markdown里面的东西归档过来吧...不过会慢慢来... ClariS 最后附上可爱的ClariS的近照~ "},"1.博客概览/自我介绍.html":{"url":"1.博客概览/自我介绍.html","title":"自我介绍","summary":"一些简短的问题和答案。","keywords":"","body":"关于我 名字： jskyzero 名字的含义： jskyzero = j + sky + zero 名字的来历： 大概是比较中二的时候自己起的，后来就拿起来用了 性别年龄等相关： 待补充（逃 社会职业： 学生 学校等相关： 待补充（逃 理想的职业： 工作两年后 被下岗 回老家开小餐馆 喜欢使用的语言： 水平和客观条件离能挑选使用语言还差的太远 对初学者要说的话： 多写代码多看书，少玩游戏少看番 上面那条建议是不是太假： 人总是需要骗一下自己的（大雾 兴趣爱好： 番剧/漫画/游戏/轻小说 等 一般性宅向偏好 圈内一句话介绍自己： 前辈你好我是萌新JSKY QAQ请多多指教 喜欢的二次元组合： ClariS（曾经 喜欢的二次元女角色： 藤宫香织（出自《一周的朋友》） 最近看过并且推荐的番剧： 《三月的狮子》（能从中看到自己的影子 最近玩过并且推荐的游戏： 《Persona 5》（来开始更新吧w PlayStation Network ID： sujiner （欢迎dalao加好友一起玩w 对未来的期望： 希望有能力担起自己的未来:) p.question { color: pink; } p.answer { color: gray; } "},"2.编程语言/C++ 模板元編程.html":{"url":"2.编程语言/C++ 模板元編程.html","title":"C++ 模板元編程","keywords":"","body":"本文將給出一些C++模板以及模板元的寫法的基本介紹，將會結合具體的例子并竟可能的降低閱讀門檻。 C++ 模板元編程 jskyzero 2019/02/04 唔，起因大概是上了一節C++模板的課程，然後之前Sushiscript的時候也沒有精力好好理順一下模板以及模板元，平時也很少用到，唔，不過還是出於好奇寫了點相關的代碼，現在把一些內容整理出來。 先從模板開始說起吧，简单来说，模板提供了一种参数化类型的能力，模板在编译时对模板形参进行参数化，编译出对应不同类型的代码，C++是支持重载的，我们的方法（或者理解成操作，毕竟这里不能单独对应函数，应该也要包括操作符，类等）可以对于不同类型有不同的行为，模板使得这种对应不同类型的不同行为实现起来较为简单。 还是稍微扯远一点吧，上面已经说了重载和模板，再来说一下泛型和多态吧，泛型允许我们在“强类型语言”中编写代码时候，使用一些在实例化时才指定类型的类型，这些类型根据不同指定的类型可以有不同的行为。多态在我看来则指相同符号的行为的差异性，比如基类储存不同子类后调用相同函数的差异性，又比如函数在面对不同参数的差异性，后者就比较类似泛型。 还是把话题撤回来，接下来将从模板，模板元，再到最后的效率比较来展开文章。 模板速覽 还是老生常谈来说一下吧，上面已经说了模板是什么了，然后模板的好处的话，除了上面说的减少工作量，还有相比虚函数的运行时多态，模板的开销更少，能提高效率。模板大概可以分为函数模板、类模板、成员模板（类的成员函数）。模板形参则可以有类型模板参数、非类型模板参数、模板模板參數。然後一些邊緣情況需要用typename關鍵字手動指明這是個類型，防止編譯器誤解，另外的一些知識比如依賴名查找（ADL）這裡也不展開說了。 給一些可能平時不太會見得到的模板寫法吧，比如底層是指針的屬性綁定。 template struct Property { // typedef member ptr type typedef MemberType ParentType::*MemberPtrType; // use pointer to change data MemberPtrType p; // bind pointer void Bind(MemberPtrType p_) { p = p_; } // change data void Set(ParentType& parent, const MemberType& value) { parent.*p = value; } }; void Property_TEST() { SomeClass sc; auto prop = Property(); prop.Bind(&SomeClass::SomeMember); prop.Set(sc, 10); assert_equal(sc.SomeMember, 10); std::cout 又比使用模板特化如從類的成員的指針中獲取成員或者類本身的類型。 #define TYPE_NAME(x) (typeid(x).name()) template struct GetMemTypeFromMemPtr { }; template struct GetMemTypeFromMemPtr { typedef Type Result; }; template struct GetClassTypeFromMemPtr { }; template struct GetClassTypeFromMemPtr { typedef ParentType Result; }; void TypeTraits_TEST() { assert_equal(TYPE_NAME(int), TYPE_NAME(int)); assert_equal( TYPE_NAME(int), TYPE_NAME(GetMemTypeFromMemPtr::Result)); assert_equal( TYPE_NAME(SomeStruct), TYPE_NAME(GetClassTypeFromMemPtr::Result)); std::cout 模板元編程速覽 從簡單的開始 在談及模板元之前，不妨先想想什麼是元編程，簡單來說，元編程是指對編程語言進行編程，舉個例子，你可以用一段shell代碼生成重複若干次打印一個語句的C代碼，這就是元編程。模板元編程則是利用模板來進行元編程，接下來將會特化到C++中來，C++中的模板因為是圖靈完備的，所以可以在編譯時候就可以執行計算操作，這樣可以把計算過程放在編譯時期，提高效率，另一方面，模板元編程大體上比較反人類，而且調試困難，這種就會不利於團隊合作，所以大概自己寫寫玩還可以。 從一個簡單的計算階乘的例子開始吧。 #include template struct Factorial { static const int result = N * Factorial::result; }; template<> struct Factorial { static const int result = 1; }; void Factorial_Part() { std::cout ::result 唔，簡單的來說，我們聲明了一個Factorial類，然後這個類是一個接受非類型模板參數的模板類，會根據接受到參數的不同而實例化出不同的類，然後關鍵的部分在於那個遞歸，有遞歸自然有終止的地方，因此我們需要用參數特化來指定終結情況的行為。 這種思維方式非常類似之前寫過的haskell中的函數式編程，比如haskell裡面的取反可以這麼寫： myNot :: Bool -> Bool myNot True = False myNot False = True -- myNot x = not x 實現一個分數 唔，依稀記得haskell當初第一個個人作業就是實現一個符號完備的分數系統，那不妨我們也挪到這裡做做試試看好了。 typedef int TYPE; template struct Pair { static const TYPE x = x_; static const TYPE y = y_; }; 我們使用int，或者long long，或者任何你想使用的整數數據類型來儲存分子和分母，為了方便更改這裡就開始就用了個別名。 template struct Abs { static const TYPE result = x > 0 ? x : -x; }; template struct GCD { static const TYPE result = GCD::result; }; template struct GCD { static const TYPE result = x; }; template struct Fraction { static const TYPE gcd = GCD::result, Abs::result>::result; // x_ y_ x y // + + + + // + - - + // - + - + // - - + + static const TYPE sign = y_ ::result / gcd; }; 然後是為了能夠化簡的最大公因數的計算（GCD），以及這裡把符號留在分子上。 template struct Addition { typedef Fraction result; }; template struct Subtraction { typedef Fraction result; }; 然後後面的就比較簡單了，加法減法乘法除法都可以隨手寫了。 template std::string FractionToString() { return \"( \" + std::to_string(fraction::x) + \" / \" + std::to_string(fraction::y) + \" )\"; }; 順路可以實現一個方便打印的函數。 實現一個列表 接下來可以稍微處理一些複雜的東西，比如列表。 typedef int TYPE; template struct Type { static const TYPE value = x; }; struct NIL { typedef NIL Head; typedef NIL Tail; }; template struct List { typedef H Head; typedef T Tail; }; 簡單的來說，我們用Type進行一次轉換，就可以把一個基礎數據類型的值變成一個類型，然後就可以列表層層嵌套，這個時候如果要實例化這個列表，會比較像這個樣子typedef List> l3;typedef List, l3> l2;。 然後來實現一些基本的操作吧： // Length template struct Length { static const size_t result = 1 + Length::result; }; template <> struct Length { static const size_t result = 0; }; 比如獲取列表的長度，插入，刪除指定位置的元素，等等，當然也包括打印。 // ListToString template std::string ListToString() { return \"(\" + std::to_string(list::Head::value) + \", \" + ListToString() + \")\"; }; template <> std::string ListToString() { return std::string(\"NIL\"); }; 唔，然後是兩個相對複雜的操作。 // CreateList template struct CreateList { template struct __CreateList { typedef List::result> result; }; template struct __CreateList { typedef List result; }; typedef typename __CreateList...>::result result; }; 我們不妨簡化一下創建列表的步驟，現在我們就可以直接typedef CreateList::result l2;這麼創建一個列表了。 // Slice [begin, end) template struct Slice { template struct Type { static const TYPE value = x; }; template struct __Slice { typedef typename __Slice::result - 1>::result, __begin, __end>::result result; }; template struct __Slice::result)>> { typedef typename __Slice, Type::result - 1)>>::result result; }; template struct __Slice, Type::result)>> { typedef __list result; }; typedef typename __Slice= 0 ? begin : 0>, Type::result ? end : Length::result>>::result result; }; 然後我們可以實現一個切片，不過感覺就會有點繁雜。 效率比较 唔，這裡的話簡單的比較一下就好，比如傳統的寫法可能是： #include // for std::cout #include \"cpp.tmp.hpp\" // for kLOOP_TIMES int fatorial(int n) { return n == 0 ? 1 : n * fatorial(n - 1); } int main() { for (int i = 0; i 雖然比較不一定準確，但是也對比了虛函數調用、循環可能被優化等等幾項，大概的結果是 # \"factorial\" time ././bin/factorial.out 0.48user 0.01system 0:00.50elapsed 99%CPU (0avgtext+0avgdata 1456maxresident)k 0inputs+0outputs (0major+415minor)pagefaults 0swaps # \"factorial with template meta programming\" time ././bin/factorial.tmp.out 0.03user 0.00system 0:00.02elapsed 106%CPU (0avgtext+0avgdata 1452maxresident)k 0inputs+0outputs (0major+413minor)pagefaults 0swaps # \"vector\" time ././bin/vector.out 4.59user 0.01system 0:04.59elapsed 100%CPU (0avgtext+0avgdata 1464maxresident)k 0inputs+0outputs (0major+417minor)pagefaults 0swaps # \"vector with template meta programming\" time ././bin/vector.tmp.out 4.54user 0.00system 0:04.57elapsed 99%CPU (0avgtext+0avgdata 1460maxresident)k 0inputs+0outputs (0major+416minor)pagefaults 0swaps # \"polymorphic\" time ././bin/polymorphic.out 0.25user 0.01system 0:00.26elapsed 101%CPU (0avgtext+0avgdata 1452maxresident)k 0inputs+0outputs (0major+415minor)pagefaults 0swaps # \"polymorphic with template meta programming\" time ././bin/polymorphic.tmp.out 0.18user 0.00system 0:00.19elapsed 94%CPU (0avgtext+0avgdata 1452maxresident)k 0inputs+0outputs (0major+414minor)pagefaults 0swaps # make all compare finished 具體的代碼可以參考下面的參考的說。 參考 只貼一個好了，是上面提及的全部的代碼都在的倉庫，如果需要參考的話可以點開看看。 "},"2.编程语言/HTML 编写静态网页工具.html":{"url":"2.编程语言/HTML 编写静态网页工具.html","title":"HTML 编写静态网页工具","keywords":"","body":"使用HTML/JavaScript的方式编写一些辅助小工具。 效率提升：使用HTML编写小工具 jskyzero 2021/06/23 为什么是HTML+JavaScript 最初在诸多GUI解决方案中犹豫了，并且把目光看向了所有人都会有的浏览器。 只要有浏览器就能打开HTML并且解析JavaScript。 解决方案 静态HTML + 简单交互。 再找一个UI库来让界面好看点。 细节展示 一个HTML的例子： 一个UI的例子 技能概率计算 概率: 计算 描述: 看起来大概如下所示： 技能概率计算 概率: 计算 描述: 一个逻辑的例子 document.getElementById(\"button\").onclick = () => { let text = document.getElementById(\"key\").value; let descriptions = document.getElementById(\"description\").value.split(\" \"); let result = document.getElementById(\"result\"); let values = text.split(\";\").map(a => parseInt(a)).filter(a => Number.isInteger(a)); let total = values.reduce((a, b) => a + b, 0); let valuesProbability = values.map(a => a / total); let valuesZip = values.map((e, i) => { // return [e, valuesProbability[i]]; return e + \"\\t\\t\" + Math.floor(valuesProbability[i] * 100) + \"%\\t\"; }); valuesZip = valuesZip.map((e, i) => { let label = descriptions[i] === undefined ? \"空\" : descriptions[i]; return label + \"\\t\\t\" + e; }) result.innerText = valuesZip.join(\"\\n\"); } 用了一些map & reduce之类的方法，还挺实用的。 "},"2.编程语言/Java GridWorld实训总结.html":{"url":"2.编程语言/Java GridWorld实训总结.html","title":"Java GridWorld实训总结","keywords":"","body":"每次实训都可以学到大量的东西，知识出现的过于密集是否能够消化呢？嘛，本文将总结中级实训GridWorld所涉及的知识，一些有用的学习思路，希望能给以后的自己一点帮助。 Java GridWorld实训总结 jskyzero 2017/03/19 阶段1：项目启动 本阶段主要是为实训项目做基本的技术准备，学会使用Vi, JAVA, Ant和Junit, 以及熟悉GridWorld的使用，并完成指定的任务。 Java：Java SE 8 Specification，这上面基本上啥都说了，快速上手的话教程很多，这里不赘述。不管怎么样开发人员记得要装JDK而不是JRE。 swing：属于JFC的一个简单GUI，框架？建立在AWT上，要求写简单GUI计算器的时候用的，教程的话可以看这个Java Swing Tutorial,总的来说在代码里面建立页面还是不太习惯，不过还行，也能用。 Ant：用XML格式写的执行各种指令的工具，类比make，不过似乎看起来是难用了一些，XML就很值得吐槽，一个属性是放在前括号里还是子元素里？括号套括号不如咱们用缩进用游标卡尺好不好，当然吐槽归吐槽，很多标签都很有用，也找到了一个模板型的build.xml，很好。忘了给教程 Junit：就像它名字一样这是单元测试的，用的不是最新版，文档看github上的应该就好。 阶段2：基本任务 本阶段我们使用提供的GridWorld接口来实现一些要求的任务，实际运用面向对象的编程思想。 Bug Variations：使用Bug Class的一些接口来实现特定运行方式的Bug，比如轨迹是环形/螺旋/Z形等等的Bug GridWorld Classes and Interfaces：熟悉GridWorld/Location/Grid/Actor等等的类的接口和结构关系，写一些继承Actor的有特定行为的Actor，比如跳跃（一次前进两格）方式前进的Bug Interacting Objects：进一步写一些行为更加复杂的Actor子类，比如前进方式/会更具周围物体改变自身属性/可以影响周围物体的属性。 Grid Data Structures：我们终于开始对Grid动手了，这里考虑用内存空间与实际格子一一对应或者使用树/哈希表等等只保存有物体的格子 阶段3：扩展任务 本阶段使用之前学习到的工具型技能来进一步辅助学习各种知识 ImageProcessing：这次我们对PNG图片下手，这是我在正常的课程教学过程中第一次发现二进制文件处理的内容，具体的PNG格式/使用接口并不重要，重要的是对二进制文件的处理和操作的思想。 MazeBug：使用深度优先算法走迷宫 N-Puzzle：重排拼图游戏（N-数码问题），广度优先算法，通过相似匹配加速寻找。 个人总结 上面已经把这次实训涉及到的知识再次罗列了一次，一路训过来还是确实能学习到东西的，知识层面的也好，为人层面的也好。 这次学习了一门新语言Java，大部分时间都是在对着特定接口的文档看看看学学学，语言本身的一些接口可能还没有接触完全，总的来说就也只是入了一个门，后面要学的东西还是很多。 然后一定要安排好时间，不要沉迷网络游戏。嗯大概就是这些。 "},"2.编程语言/Python 富文本转CSV.html":{"url":"2.编程语言/Python 富文本转CSV.html","title":"Python 富文本转CSV","keywords":"","body":"最近遇到的数据处理问题，做个记录，以后可以在此基础上修改为其他文本处理程序！ Python 富文本转CSV格式 jskyzero 2023/04/16 背景概述 打算制作一个朴素的索引网页，里面是GameAIPro的大量文章，在原有信息的基础上多一些需要显示的批注字段。本来是打算直接动手的，但是写了10篇就感觉markdown表格的长行，编辑起来太难受了。 研究了一下github自带的jekyll是可以用_data/*.csv来实现数据导入的，再自己随便写点jekyll的模板就完事了。使用csv格式，我们就可以来使用类excel的表格工具管理编辑数据，不错。 问题又来到了如何将现有网站上的信息转化到csv格式，手动吗？约200篇文章，手动多少有点费事，还是写个中转工具吧，就决定是你了，Python！ 控制流模型 我们要做的事情大概是这样： 继续用用面向过程的方式来描述的话，Python的控制流大概是这样子的： 面向过程的程式写的有些多了，不如这次试试面向对象的方式： 编码部分 载入文件 对每一行进行单独处理： def read(self, file_path): \"\"\"read txt\"\"\" with open(file_path, \"r\", encoding=\"utf-8\") as txt_file: for line in txt_file: if line.startswith(\"Section\"): self.current_section = line.split(':')[1].strip() # print(self.current_section) elif line.startswith(\"-\") or line == \"\\n\": pass else: article = Article(line, self.current_section) self.articles.append(article) return self 文本类的文本处理 这里有一个有意思的工具方法，slice，将字符串进行切分，再对切分后的字符串进行一次切片操作，以此来快速将字符串中的关键信息提取出来。 def __init__(self, line, section): self.section = section # 2\\. [title](src), authur [demo code](demo_src)\\ self.index, line = self.slice(line, '.', None, -1, 1, None) # [title](src), authur [demo code](demo_src)\\ self.title, line = self.slice(line, ']', 1, None, 1, None) # (src), authur [demo code](demo_src)\\ self.src, line = self.slice(line, ')', 1, None, 2, None) if \"demo\" in line: # authur [demo code](demo_src)\\ self.authur, line = self.slice(line, '[', None, None, None, None) # [demo code](demo_src)\\ _, line = self.slice(line, '(', None, None, None, None) # (demo_src)\\ self.demo_src, _ = self.slice(line, ')', 1, None, None, None) else: # authur\\ self.authur = line self.demo_src = \"\" # authur\\ if self.authur.endswith(\"\\\\\"): self.authur = self.authur[:-1] # print(str(self)) @staticmethod def slice(str, chr, a=None, b=None, c=None, d=None): index = str.find(chr) left = str[0:index].strip() right = str[index:].strip() return (left[a:b].strip(), right[c:d].strip()) 处理导出 这部分就比较简单了，直接map一下然后写入文件就行。 def to_csv(self): self.csv = map(lambda x: x.to_csv(), self.articles) return self def write(self, file_path): with open(file_path, 'w') as f: # using csv.writer method from CSV package write = csv.writer(f) write.writerow(Article.to_csv_header()) write.writerows(self.csv) return self 参考 源码 "},"2.编程语言/Python 配置数据表.html":{"url":"2.编程语言/Python 配置数据表.html","title":"Python 配置数据表","keywords":"","body":"唔，首先说一下这是在生产环境，生产环境自然是和自己写着玩的环境是不一样的处理方法，生产环境中我们想要的大概是正确、稳定、高效。 Python 配置数据表 jskyzero 2019/01/18 背景概述 是这样的，出于某种目的，现在我需要配置某个表格，表格是这样的，一部分是配置了一些人数属性，另一部分则需要配置关卡与人物属性的对应关系，用于在关卡中使用，关卡中是需要使用到三位角色，目前是将48名角色随机挑选三位给了关卡，但是这样可能会出现三位某些属性相同的角色的情况，为此需要修改配置。 目前支持的方式是，从若干角色中挑选三位，和若干相同关卡对应角色中，随机一种对应，在和相关同（前）学（辈）沟通过以后拒绝在程序部分增加逻辑，希望维持原有配置方式，考虑到之前是采用第一种方式配置，这次需要采用第二种减少挑选范围，扩大同可能挑选对应方式。 但是仔细一想这炸了，这要是枚举出来过百我都懒得配了，之前一个关卡我只写了一行，现在随便要翻若干倍，显然这里靠蛮力是不行的，好在后台逻辑不改，没事，我可以前台手动枚举，这个本质上数学模型还是很简单，具体涉及到一点excel读取，写入，和数据的概率统计处理方面的知识。 模型抽象 再次提及这是在生产环境，甚至没有办法去装某些包，翻了下好歹有个xlrd可以用来读取excel，足够了足够了，暂时是打算写出csv，然后手动拷贝到表中储存，excel中的操作就不太熟悉了，我可以相对模拟输出格式，直接拷贝粘贴，实际上面对几十万行的excel数据，手动修改就会有点不现实了。 那么大概的流程是，读入角色，模拟随机方式，然后去掉不合适的组合，然后写出csv格式文件，然后手工拷贝粘贴至源表格。 编码部分 引入包，常量定义（字符常量已经删除，反正是无意义的字符序列） import xlrd # for excel read import csv # for writerows import itertools # for chain ROLE_NUM = 10 # static string EXCEL_PATH = OUTPUT_PATH = PveRobotConf_Name = PveRobotAttrs_Name = PveRobotAttrs_ID_Name = PveRobotAttrs_JOB_Name = 数据读入 xlrd的方式是先获得book，然后book打开sheet，sheet再获取行、列、或者某个格子，要注意的xlrd只是读取，是没有保存相关接口的。 def read_data(): # read data book = xlrd.open_workbook(EXCEL_PATH); PveRobotConf = book.sheet_by_name(PveRobotConf_Name) PveRobotAttrs = book.sheet_by_name(PveRobotAttrs_Name) sh = PveRobotAttrs titles = sh.row_values(0) # print(\"numbers of worksheets: {0}\".format(book.nsheets)) # print(\"worksheet names: {0}\".format(book.sheet_names())) # print(\"{0} {1} {2}\".format(sh.name, sh.nrows, sh.ncols)) data = [sh.col_values(titles.index(PveRobotAttrs_ID_Name),4), sh.col_values(titles.index(PveRobotAttrs_JOB_Name),4)] return data 生成与筛选 逻辑相对简单，一些对数据切片和匹配的细节就不再展开说了。 def process_each_level(begin, end, data, result, level): # python list process # transpose data = map(list, zip(*data)) # map to int data = map(lambda l : map(int, l), data) # get each role between begin and end data = map(lambda x : data[x::ROLE_NUM], range(begin, end)) # transpose make each sub role together data = map(list, zip(*data)) # join together # data = itertools.chain(*data) # eight role select 4 for each_select in itertools.combinations(data, 4): process_each_select(each_select, result, level) return result def process_each_select(each_select, result, level): for each_result in itertools.product(*each_select): ids = map(lambda l: l[0], each_result) roles = map(lambda l: l[1], each_result) # check role if (len(set(roles)) == len(roles)): each_result = list(itertools.chain(*[[len(result) + 1], [level], [\"\"], ids])) result.append(each_result) 输出 因为有大量关卡，这里我们修改config就可以配置关卡与角色起终止一次性生成全部配置。 def process_all(): result = [] data = read_data() config = [ [10000, [0,2]],] for line in config: process_each_level(line[1][0],line[1][1], data, result, line[0]); return result if __name__ == \"__main__\": result = process_all() # save to csv file with open(OUTPUT_PATH, 'wb') as f: csv.writer(f).writerows(result) 总结 唔，中间的删选部分或许可以再抽象一层，但是也没必要，毕竟是能work就好，生成后大概几十万行的配置，如果手工的话感觉我一辈子就没了。 "},"2.编程语言/编程语言学习路径.html":{"url":"2.编程语言/编程语言学习路径.html","title":"编程语言学习路径","keywords":"","body":"本文試圖論述明確如何學習一門編程語言，用以以後學習的參考。 编程语言学习路径 jskyzero 2020/01/31 以下施工中... "},"3.计算机科学/人工智能-搜索算法.html":{"url":"3.计算机科学/人工智能-搜索算法.html","title":"人工智能 搜索算法","keywords":"","body":"本文將以八数码问题为例，讨论在解决问题时候的搜索算法的选择和优化。 人工智能-搜索算法 jskyzero 2017/10/11 以简单的问题切入 其实不用特别关注八数码究竟是什么问题，总之也是给我们一个输入，输出，变化规则，我们需要想办法找到从输入到输出的一个变化的过程， 我们来具体看下输入和输出，输入的是包含0的九个数，代表九个格子现在上面的数字，输出是按照1-8，最后是0的顺序。也就是要把数字放到对应的格子的意思，然后变化方法就是，移动0和上下左右的数字交换。 将问题转化到搜索上 每个状态可以理解为，一个节点，由一个状态转化到另一个状态可以理解为一条有向边，发现重复的状态的话就不在生成，这样我们就把这个问题变成了一个有向无环图（树），我们只要遍历这棵树，找到符合的目标状态，就算解决问题了。 那么树的遍历我们是熟悉的，无外乎深度优先广度优先。 广度优先可以找到最优解，但是相对而言对内存和时间的需求要高一些，深度的话可以在内存不足的时候起到关键作用。 随便实现一下逻辑 引入头文件 import heapq initial = [8, 7, 6, 5, 4, 3, 2, 1, 0] final = [1, 2, 3, 4, 5, 6, 7, 8, 0] 一些基本函数 def sub_move_choice(now_state): next_state = [] # 0 1 2 # 3 4 5 # 6 7 8 index = now_state.index(0) if index % 3 == 0: next_state.append(swap(now_state, index, index + 1)) if index % 3 == 1: next_state.append(swap(now_state, index, index - 1)) next_state.append(swap(now_state, index, index + 1)) if index % 3 == 2: next_state.append(swap(now_state, index, index - 1)) if index // 3 == 0: next_state.append(swap(now_state, index, index + 3)) if index // 3 == 1: next_state.append(swap(now_state, index, index - 3)) next_state.append(swap(now_state, index, index + 3)) if index // 3 == 2: next_state.append(swap(now_state, index, index - 3)) return next_state def swap(now_state, left, right): new_state = now_state[:] temp = new_state[left] new_state[left] = new_state[right] new_state[right] = temp return new_state 核心部分 def BFS(initial_state, end_state): next_states = [initial_state] traveled = set(tuple(initial_state)) depth = 0 while not end_state in next_states and not len(next_states) == 0: depth = depth + 1 new_next_states = [] for next_state in next_states: for sub_next_state in sub_move_choice(next_state): if not tuple(sub_next_state) in traveled: new_next_states.append(sub_next_state) traveled.add(tuple(sub_next_state)) next_states = new_next_states[:] # print(\"depth = \", depth, # \"len = \", len(new_next_states), # \"traveled = \", len(traveled)) print( \"FAILED\" if len(next_states) == 0 else \"traveled = \", len(traveled)) def DFS(initial_state, end_state, Afunction): next_states = [] heapq.heappush( next_states, (-Afunction(initial_state, end_state), initial_state)) traveled = set(tuple(initial_state)) while not len(next_states) == 0: top_state = heapq.heappop(next_states)[-1] if top_state == end_state: print(\"traveled = \", len(traveled)) return else: for next_state in sub_move_choice(top_state): if not tuple(next_state) in traveled: heapq.heappush( next_states, (-Afunction(next_state, end_state), next_state)) traveled.add(tuple(next_state)) print(\"FAILED\") def diferent_bit(one_state, another_state=final): return -sum([0 if x == y else 1 for(x, y) in zip(one_state, another_state)]) def diferent_sum(one_state, another_state=final): return -sum([abs(x - y) for(x, y) in zip(one_state, another_state)]) def manhadun_space(one_state, another_state): space = 0 for i in range(0, 9, 1): j = another_state.index(one_state[i]) space = space + abs(j % 3 - i % 3) + abs(j // 3 - i // 3) return -space 我们可以看到这个差别，还是挺明显的。 BFS(initial, final) DFS(initial, final, diferent_sum) DFS(initial, final, diferent_bit) DFS(initial, final, manhadun_space) # traveled = 181447 # traveled = 18656 # traveled = 1327 # traveled = 247 "},"3.计算机科学/字符编码.html":{"url":"3.计算机科学/字符编码.html","title":"字符编码","keywords":"","body":"将会涉及到Unicode、UTF-8、UTF-16编码问题，可以参考网络上的相关介绍，这里试图以相对总结的方式来论述这些知识，并提供C的编码实现。 字符编码 jskyzero 2017/02/06 Unicode Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。 很多传统的编码方式都有一个共同的问题，即容许电脑处理双语环境（通常使用拉丁字母以及其本地语言），但却无法同时支持多语言环境（指可同时处理多种语言混合的情况）。而统一码为每一个字符而非字形定义唯一的代码（即一个整数）。换句话说，统一码以一种抽象的方式（即数字）来处理字符，并将视觉上的演绎工作（例如字体大小、外观形状、字体形态、文体等）留给其他软件来处理，例如网页浏览器或是文字处理器。 在表示一个Unicode的字符时，通常会用“U+”然后紧接着一组十六进制的数字来表示这一个字符 编码和实现 统一码的编码方式与ISO 10646的通用字符集概念相对应。目前实际应用的统一码版本对应于UCS-2，使用16位的编码空间。也就是每个字符占用2个字节。这样理论上一共最多可以表示2^16（即65536）个字符。基本满足各种语言的使用。实际上当前版本的统一码并未完全使用这16位编码，而是保留了大量空间以作为特殊使用或将来扩展。 上述16位统一码字符构成基本多文种平面。最新（但未实际广泛使用）的统一码版本定义了16个辅助平面，两者合起来至少需要占据21位的编码空间，比3字节略少。但事实上辅助平面字符仍然占用4字节编码空间，与UCS-4保持一致。未来版本会扩充到ISO 10646-1实现级别3，即涵盖UCS-4的所有字符。UCS-4是一个更大的尚未填充完全的31位字符集，加上恒为0的首位，共需占据32位，即4字节。理论上最多能表示2^31个字符，完全可以涵盖一切语言所用的符号。 基本多文种平面的字符的编码为U+hhhh，其中每个h代表一个十六进制数字，与UCS-2编码完全相同。而其对应的4字节UCS-4编码后两个字节一致，前两个字节则所有位均为0。 Unicode转换格式 Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF） 例如，如果一个仅包含基本7位ASCII字符的Unicode文件，如果每个字符都使用2字节的原Unicode编码传输，其第一字节的8位始终为0。这就造成了比较大的浪费。对于这种情况，可以使用UTF-8编码，这是一种变长编码，它将基本7位ASCII字符仍用7位编码表示，占用一个字节（首位补0）。而遇到与其他Unicode字符混合的情况，将按一定算法转换，每个字符使用1-3个字节编码，并利用首位为0或1进行识别。这样对以7位ASCII字符为主的西文文档就大幅节省了编码长度（具体方案参见UTF-8）。类似的，对未来会出现的需要4个字节的辅助平面字符和其他UCS-4扩充字符，2字节编码的UTF-16也需要通过一定的算法进行转换。 再如，如果直接使用与Unicode编码一致（仅限于BMP字符）的UTF-16编码，由于每个字符占用了两个字节，在麦金塔电脑（Mac）机和个人电脑上，对字节顺序的理解是不一致的。这时同一字节流可能会被解释为不同内容，如某字符为十六进制编码4E59，按两个字节拆分为4E和59，在Mac上读取时是从低字节开始，那么在Mac OS会认为此4E59编码为594E，找到的字符为“奎”，而在Windows上从高字节开始读取，则编码为U+4E59的字符为“乙”。就是说在Windows下以UTF-16编码保存一个字符“乙”，在Mac OS环境下打开会显示成“奎”。此类情况说明UTF-16的编码顺序若不加以人为定义就可能发生混淆，于是在UTF-16编码实现方式中使用了大端序（Big-Endian，简写为UTF-16 BE）、小端序（Little-Endian，简写为UTF-16 LE）的概念，以及可附加的字节顺序记号解决方案，目前在PC机上的Windows系统和Linux系统对于UTF-16编码默认使用UTF-16 LE。 UTF-8 UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或发送文字的应用中，优先采用的编码。 UTF-8使用一至六个字节为每个字符编码（尽管如此，2003年11月UTF-8被RFC 3629重新规范，只能使用原来Unicode定义的区域，U+0000到U+10FFFF，也就是说最多四个字节）： 128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。 带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要两个字节编码（Unicode范围由U+0080至U+07FF）。 其他基本多文种平面（BMP）中的字符（这包含了大部分常用字，如大部分的汉字）使用三个字节编码（Unicode范围由U+0800至U+FFFF）。 其他极少使用的Unicode 辅助平面的字符使用四至六字节编码（Unicode范围由U+10000至U+1FFFFF使用四字节，Unicode范围由U+200000至U+3FFFFFF使用五字节，Unicode范围由U+4000000至U+7FFFFFFF使用六字节）。 编码 对于UTF-8编码中的任意字节B，如果B的第一位为0，则B独立的表示一个字符(ASCII码)； 如果B的第一位为1，第二位为0，则B为一个多字节字符中的一个字节(非ASCII字符)； 如果B的前两位为1，第三位为0，则B为两个字节表示的字符中的第一个字节； 如果B的前三位为1，第四位为0，则B为三个字节表示的字符中的第一个字节； 如果B的前四位为1，第五位为0，则B为四个字节表示的字符中的第一个字节； UTF-16 UTF-16是Unicode字符编码五层次模型的第三层：字符编码表（Character Encoding Form，也称为\"storage format\"）的一种实现方式。即把Unicode字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。Unicode字符的码位，需要1个或者2个16位长的码元来表示，因此这是一个变长表示。 UTF-16可看成是UCS-2的父集。在没有辅助平面字符（surrogate code points）前，UTF-16与UCS-2所指的是同一的意思。但当引入辅助平面字符后，就称为UTF-16了。 UTF-16的编码模式 UTF-16的大尾序和小尾序存储形式都在用。一般来说，以Macintosh制作或存储的文字使用大尾序格式，以Microsoft或Linux制作或存储的文字使用小尾序格式。 为了弄清楚UTF-16文件的大小尾序，在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文本文件是以UTF-16编码，其中U+FEFF字符在UNICODE中代表的意义是ZERO WIDTH NO-BREAK SPACE，顾名思义，它是个没有宽度也没有断字的空白。 辅助平面中的码位从U+10000到U+10FFFF，共计FFFFF个，即220=1,048,576个，需要20位来表示。如果用两个16位长的整数组成的序列来表示，第一个整数（称为前导代理）要容纳上述20位的前10位，第二个整数（称为后尾代理）容纳上述20位的后10位。还要能根据16位整数的值直接判明属于前导整数代理的值的范围（210=1024)，还是后尾整数代理的值的范围（也是210=1024）。因此，需要在基本多语言平面中保留不对应于Unicode字符的2048个码位，就足以容纳前导代理与后尾代理所需要的编码空间。这对于基本多语言平面总计65536个码位来说，仅占3.125%. 由于前导代理、后尾代理、BMP中的有效字符的码位，三者互不重叠，搜索是简单的：一个字符编码的一部分不可能与另一个字符编码的不同部分相重叠。这意味着UTF-16是自同步（self-synchronizing）:可以通过仅检查一个码元就可以判定给定字符的下一个字符的起始码元. C语言描述-实际演练 UCS-2_to_UTF-8 #include #define UCS_SIZE 2 #define UTF_SIZE 3 void UCS_2_to_UTF_8(FILE * fp) { FILE * out = fopen(\"UTF-8\", \"w\"); // write to target char UCS[UCS_SIZE]; // store UCS-2 char UTF[UTF_SIZE]; // store UTF-8 size_t UTF_length; // store UTF-8 length unsigned long Unicode; // store Unicde // check the file is Bid Endian or Little Endian // Bid Endian : FE FF Little Endian FF FE, true means Bid Endian int endian = ((unsigned char)fgetc(fp) = 0; i--) Unicode = (Unicode = 0x00000080 && Unicode > 6) & 0x1F) | 0xC0; UTF_length = 2; } else if ( Unicode >= 0x00000800 && Unicode > 6) & 0x3F) | 0x80; *UTF = ((Unicode >> 12) & 0x0F) | 0xE0; UTF_length = 3; } // write UTF-8 to file if(endian) { for (size_t i = 0; i = 0; i--) { fputc(UTF[i], out); } } } fclose(out); return; } int main(int argc, char * argv[]) { if(argc != 2) { printf(\"Usage: ./UCS_2_to_UTF_8 \\n\"); return -1; } FILE * fp = fopen(argv[1], \"r\"); // read from file if(!fp) { // check whether the file can be open printf(\"File opening failed\\n\"); return -1; } UCS_2_to_UTF_8(fp); fclose(fp); return 0; } UTF-8_to_UCS-2 #include // for FILE fopen feof fclose #define UCS_SIZE 2 #define UTF_SIZE 3 void UTF_8_to_UCS2(FILE * fp ) { FILE * out = fopen(\"UCS-2\", \"w\"); // write to target char UCS[UCS_SIZE] = { 0xFE, 0xFF }; // store UCS-2 char UTF[UTF_SIZE]; // store UTF-8 size_t UTF_length; // store UTF-8 length unsigned long Unicode; // store Unicde int break_flag = 0; // out the file Bid Endian or Little Endian // Bid Endian : FE FF Little Endian FF FE, this is Bid Endian fputc((unsigned char)UCS[0], out); fputc((unsigned char)UCS[1], out); while (!feof(fp)) { Unicode = 0; // for every word, read from file and change to Unicode UTF[0] = fgetc(fp); if (0 == ((unsigned char)UTF[0] >> 7)) { // 0zzzzzzz（00-7F） UTF_length = 1; Unicode = (unsigned char)UTF[0]; } else if (6 == ((unsigned char)UTF[0] >> 5)) { // 110yyyyy（C0-DF) 10zzzzzz(80-BF） UTF_length = 2; UTF[1] = fgetc(fp); Unicode = (((unsigned char)UTF[0] & 0x1f) > 4)) { // 1110xxxx(E0-EF) 10yyyyyy 10zzzzzz UTF_length = 3; UTF[1] = fgetc(fp); UTF[2] = fgetc(fp); Unicode = (((unsigned char)UTF[0] & 0xf) > 8; UCS[1] = (Unicode & 0xff); fputc((unsigned char)UCS[0], out); fputc((unsigned char)UCS[1], out); } fclose(out); return; } int main(int argc, char * argv[]) { if(argc != 2) { printf(\"Usage: ./UTF-8_to_UCS2 \\n\"); return -1; } FILE * fp = fopen(argv[1], \"r\"); // read from file if(!fp) { // check whether the file can be open printf(\"File opening failed\\n\"); return -1; } UTF_8_to_UCS2(fp); fclose(fp); return 0; } "},"3.计算机科学/字节顺序.html":{"url":"3.计算机科学/字节顺序.html","title":"字节顺序","keywords":"","body":"本文将讲述关于编程中可能会遇到并且引起疑惑的字节顺序的相关问题，配合之前关于UTF-8编码的部分一起食用效果更佳。 字节顺序 jskyzero 2017/04/30 字节顺序，又称端序或尾序（英语：Endianness）。在计算机科学领域中，是跨越多字节的程序对象的存储规则。 有仔细看过关于编码的那篇文章的读者应该已经有留意到关于字节顺序的问题（具体来说就是UTF-16的BE/LE两种不同的表示方式）。 这里我们将继续就大小头问题做一个深入的理解，从问题的来源到解决方案。 起源 使用过C语言的读者可能知道，一个类型为int的变量可能占用四个字节，很多其他的类型也是这样，需要多个字节为一个单位，每个字节由于硬件设计的原因位的顺序是一般是固定的，多个字节排布的顺序则有可能不同。 我们一般将最高有效位字节储存在最低的内存地址的叫做大端序，最低位字节储存在最低的内存地址的叫做小端序。举例来说： data = 0x01020304 低位地址 >> 高位地址 大端序 0x01 | 0x02 | 0x03 | 0x04 小端序 0x04 | 0x03 | 0x02 | 0x01 查看字节序 根据字节序的定义，我们只要知道了数据在内存中的保存方式，自然可以很容易的判断它是那种字节序列。这里以C语言描述为例。具体的逻辑可以参考实际代码，如下。 #include // for printf() int main() { // 假定int为4byte int a = 0x01020304; // 获取首byte地址，并用（也是一个byte的char类型）的指针存储 char *b = (char *)&a; // 依照地址增长，打印每个byte for (int i = 0; i 关于Hexdump 以下故事只告诉我们要注意仔细看文档 关于该工具具体的介绍和使用方法请参考man等 使用Hexdump我们可以以字节为单位很方便的查看文件的原貌，但是请注意关于这个工具的默认查看方式 -x Two-byte hexadecimal display. Display the input offset in hexa‐ decimal, followed by eight, space separated, four column, zero- filled, two-byte quantities of input data, in hexadecimal, perline. ... If no format strings are specified, the default display is equivalent to specifying the -x option. 举例来说，你现在有一个文件里面写入的是123(换个表示方法0x313233)，假定你的机器是小端序，使用hexdump不加参数查看，你将看到 0000000 3231 0033 0000003 当然我们直接用hd指令就挺好的 00000000 31 32 33 |123| 00000003 毕竟 -C Canonical hex+ASCII display. Display the input offset in hexa- decimal, followed by sixteen space-separated, two column, hexa- decimal bytes, followed by the same sixteen bytes in %_p format enclosed in ``|'' characters. Calling the command hd implies this option. 经常会遇到的其他问题 字节顺序标记 BOM大概就是个概念，在编码上还挺容易被烦到，以下取自某不靠谱的百科 字节顺序标记（英语：byte-order mark，BOM）是位于码点U+FEFF的统一码字符的名称。当以UTF-16或UTF-32来将UCS/统一码字符所组成的字符串编码时，这个字符被用来标示其字节序。它常被用来当做标示文件是以UTF-8、UTF-16或UTF-32编码的记号。 字符U+FEFF如果出现在字节流的开头，则用来标识该字节流的字节序，是高位在前还是低位在前。如果它出现在字节流的中间，则表达零宽度非换行空格的意义，用户看起来就是一个空格。从Unicode3.2开始，U+FEFF只能出现在字节流的开头，只能用于标识字节序，就如它的名称——字节序标记——所表示的一样；除此以外的用法已被舍弃。取而代之的是，使用U+2060来表达零宽度无断空白。 许多视窗程序（包含记事本）会添加字节顺序标记到UTF-8文件。然而，在类Unix系统（大量使用文本文件，用于文件格式，用于进程间通信）中，这种作法则不被建议采用。因为它会妨碍到如解译器脚本开头的Shebang等的一些重要的码的正确处理。它亦会影响到无法识别它的编程语言。如gcc会报告源码档开头有无法识别的字符。而在PHP中，如果没有激活输出缓冲（output buffering），它会使得页面内容开始被送往浏览器（即：用户头文件已被提交），这使PHP脚本无法指定用户头文件（HTTP Header）。字节顺序标记在UTF-8中被表示为序列EF BB BF，对大部分未准备好处理UTF-8的文本编辑器及网页浏览器而言，在ISO-8859-1的环境中则会显示ï»¿。 如果之前有遇到相关情况的，大概看了上面的说明就明白了。 换行符 换行（英语：newline，Line break，end-of-line(EOL), Line Feed(LF)），在计算机领域中是一种加在文字最后位置的特殊字元，在换行字元的下一个字元将会出现在下一行，实际上换行字元根据不同的硬件平台或操作系统平台会有不同的编码方式。 换行字符可以看作是行的结束符，也可以看作行之间的分隔符，这两种处理方式之间存在一些歧义。如果换行字符被当作分隔符，那么文件的最后一行就不需要再有换行字符。但是多数系统的做法是在最后一行的后面也加上一个换行字符，也就是把换行字符看作是行的结束符。这样的程序在处理末行没有换行字符的文件时，可能会存在问题。相反地，有的程序把换行符看作分隔符，就会把最末尾的换行字符看作是新行的开始，也就是多出了一个空行。 以ASCII为基础的或相容的字元集使用分别LF（Line feed，0Ah）或CR（Carriage Return，0Dh）或CR+LF；下面列出各系统换行字元编码的列表 LF：在Unix或Unix相容系统（GNU/Linux，AIX，Xenix，Mac OS X，...）、BeOS、Amiga、RISC OS CR+LF：MS-DOS、微软视窗操作系统（Microsoft Windows）、大部分非Unix的系统 CR：Apple II家族，Mac OS至版本9 请尤其注意，某些语言对文件的以文本文件打开的方式是根据平台不同而修改过写入的换行符的，这样将会在试图以直接按字节写入文件（二进制处理方式）时带来很多不必要的麻烦，所以后者一定要以二进制方式打开文件。具体可以参考下面的参考。 参考 Difference between CR LF, LF and CR line break types? Python file IO 'w' vs 'wb' fopen中w w+ wb区别 详解大端模式和小端模式 "},"3.计算机科学/深度&广度优先搜索.html":{"url":"3.计算机科学/深度&广度优先搜索.html","title":"深度&广度优先搜索","keywords":"","body":"深度&广度优先搜索 jskyzero 2020/10/12 本文将以LeetCode的例题为例子，用Python语言实现深度优先、广度优先搜索。 DFS/深度优先 例题：Increasing Order Search Tree 题意：前序深度优先遍历即可。 因为要求一个特定的输出格式，所以先简单实现这部分的逻辑 def saveResult(self, node: TreeNode) -> None: if node == None: return # print(node.val) if self.result == None: self.result = TreeNode(node.val, None, None) self.resultTop = self.result else: self.resultTop.right = TreeNode(node.val, None, None) self.resultTop = self.resultTop.right 递归形式的深度优先很好写： # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def increasingBST(self, root: TreeNode) -> TreeNode: self.result = None self.dfs(root) return self.result def dfs(self, root: TreeNode) -> None: if root == None: return self.dfs(root.left) self.saveResult(root) self.dfs(root.right) 简单来说，注意None的判断，以及是前序中序还是后序就行。 这里也提供一个用栈替代递归实现的版本： def dfs(self, root: TreeNode) -> None: if root == None: return stack = [root] while (len(stack) != 0): top = stack.pop() # print(len(stack)) if top.left == None and top.right == None: self.saveResult(top) else: left = top.left right = top.right top.left = None top.right = None if right != None: stack.append(right) stack.append(top) if left != None: stack.append(left) 简单来说，用栈的是否为空来一直遍历，取出栈的首个元素，并按照顺序反向压进栈即可。 有一个需要注意的事情是这里将处理的栈定元素手动变成了叶子节点重新压栈，因为不是中序遍历，后续再处理到这个元素如果没有取出左右相连节点，会再次将左右相连节点压栈从而死循环。 BFS/广度优先 例题：Symmetric Tree 题意：对根节点右边的子树进行反向的遍历与左边比较即可。 这里其实不一定严格要广度优先，不过广度优先是最普遍的遍历树的打印方式。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSymmetric(self, root: TreeNode) -> bool: if root == None: return True left = [] right = [] self.bfsLeft(root.left, left) self.bfsRight(root.right, right) # print(left) # print(right) return left == right def bfsLeft(self, root: TreeNode, result: list): queen = [root] while len(queen) != 0: top = queen.pop(0) if top != None: result.append(top.val) queen.append(top.left) queen.append(top.right) else: result.append(None) return result def bfsRight(self, root: TreeNode, result: list): queen = [root] while len(queen) != 0: top = queen.pop(0) if top != None: result.append(top.val) queen.append(top.right) queen.append(top.left) else: result.append(None) return result 用队列实现，其实还算简单，不过这里因为空值也要比较所以空值的处理方式不太一样。 当然也可以用递归形式的DFS实现： def bfsLeft(self, top: TreeNode, result: list): if top != None: result.append(top.val) self.bfsLeft(top.left, result) self.bfsLeft(top.right, result) else: result.append(None) return result def bfsRight(self, top: TreeNode, result: list): if top != None: result.append(top.val) self.bfsRight(top.right, result) self.bfsRight(top.left, result) else: result.append(None) return result 如果硬要用递归本质的DFS来模仿BFS的打印的话，可以考虑引入额外的标记字段 不过就有点得不尝试，毕竟DFS很容易爆栈，而BFS则可以比较方便的控制队列大小。 "},"4.软件工具/Hexo 搭建个人博客.html":{"url":"4.软件工具/Hexo 搭建个人博客.html","title":"Hexo 搭建个人博客","keywords":"","body":"这篇博文将总结这个博客是怎样构建的，认真看完以后当然可以建立出和目前您看到的博客类似或者更好的站点，本文将假定您有一定的编程基础，如果您是初次接触编程，可能需要认真阅读文中给出的参考资料。 Hexo 搭建个人博客 jskyzero 2017/01/19 致谢：感谢Mesekovic，AT，和 hexo-theme-material 主题的开发者们。 言语所无法传达到的感情，希望总有一天能被知悉。 初始化博客 当出了问题，错误，卡住的时候，您可以在Google上搜索报错信息或者您需要完成的目的，很多错误都有前人犯过，有些错误也需要自己经历一次才能成长。 安装前置软件 请确保您拥有以下几样东西 计算机的管理员权限 一个shell程序 一个文本编辑程序 所做的事和您所使用的系统无关，您可以选择 Microsoft Windows 10 Ubuntu 16.04 LTS mac OS sierra 等任何您喜欢的系统，或许某些时候受限于需要使用的软件存在的平台，但是尽可能把事情纯粹化专注化是没有错的，以shell为例，在Microsoft Windows 10您可以使用 PowerShell，类Unix系统可以使用Ternimal。 我们所要学习的核心是 hexo, hexo是一个快速、简介且高效的博客框架，您可以参考hexo的文档来完成整个初始化博客部分的内容，不过可能具有一些基本Web课程的知识可能会比较好，例如HTML、CSS、JavaScript、Nodejs的使用。 要安装hexo我们首先需要安装nodejs，利用nodejs的npm包管理来安装hexo，（官方文档上还要求安装Git，这个后面会用到所以也一并装了比较好，具体的安装方法可以先去到对应的官方网站，找到文档部分阅读文档或者教程安装。） 在完成了前置工作以后就可以用如下指令安装hexo npm install -g hexo-cli 简单的开始 安装完hexo以后我们可以先从一个简单的示例（HelloWorld）入手，接触任何一个复杂的新技术时最好都从一个简单的例子开始，逐步理解，明白这个技术所解决的问题，以及背后的大概的工作原理，这样可能对掌握如何更好的使用这门技术有帮助，毕竟写程序很大程度上来讲都是一个举一反三的过程。 hexo init cd npm install 这样就初始化了一个简单的示例，您可以在hexo的文档中看到更多关于这个示例的信息，比如文件结构和一些配置信息，这对接下来要做的事情很有帮助，有些时候偷懒总是要付出代价的，所以还是浏览一遍hexo的文档明白一个大概比较好，这样能保证您接下来能够进行的更加顺利。 使用如下指令可以将该博客挂在localhost:4000上，打开浏览器输入对应ip:port就可以预览博客的效果。 hexo server 您可以在官方文档上找到该指令对应的简化版本。 安装博客主题 再次感谢 hexo-theme-material 的开发人员的工作 我们所要使用的主题名字是material，您可以浏览它的官方站点中的文档部分，完成接下来的几乎全部问题。 我们还是大概的走一遍流程。 # 安装到根目录下的 node_modules 里面 npm install hexo-material # 将其挪到 themes 目录下 mv node_modules/hexo-material themes/ 然后更改根目录下的_config.yml文件，将默认主题修改为 hexo-material 就可以了。 我们可以再次本机挂起一次观察情况。 自定义化 我们将要完成两个部分的自定义化，一个是根目录下的_config.yml文件，一个是hexo-material目录下的_config.yml文件，两者都有官方中文文档可以参考，特别是hexo-material的文档简直好用，对着文档慢慢设置每个的值吧。 如果对这些自定义化还是不满，您可以直接修改主题的源样式表或者自己写自己的主题，当然这需要您对整个博客体系有一定了解，有些具体部件都要自己动手。 后记 如果您认真的完成到这里，那么更新博客文章等内容是完全不需要赘言的，至于如何让其他人看见自己的博客，我们可以使用免费的Github Pages，使用hexo的部署可以一键发布。 不过还是需要事先提醒注意文件大小，比如使用的图片啊等等，要不然不仅仅是推送到服务器上需要的时间长，用户浏览所载入页面所需要的时间也会变长。 最后可以参考一个前人的博文，您可以在这上面找到更多关于Hexo + Github Pages的信息，从内容上来讲也比本文更加详实，祝顺利。 嘛，新的开始w "},"4.软件工具/OpenRefine 数据处理.html":{"url":"4.软件工具/OpenRefine 数据处理.html","title":"OpenRefine 数据处理","keywords":"","body":"本文将讲述OpenRefine是什么，OpenRefine怎么用，以及回答实验留下的问题。 OpenRefine 数据处理 jskyzero 2020/03/04 OpenRefine简介 OpenRefind，之前又被称为Google Refine，是一个开源的数据处理应用程序。可以用来清洗数据/转化数据。 OpenRefind完全建立在本地，使用网页交互，通俗来讲，通过载入特定格式文件新建项目，每个项目是一个表，可以对表中的数据进行加工和处理，包括合并类似项，删除项，修改项目值，最后可以导出为指定格式。完成获取到的数据的初步提纯处理。 OpenRefine使用 可以从官方的下载界面下载对应系统的软件包，请注意，该软件需要Java环境，顺手需要先下个最新版本的Java。 接下来的使用以Windows 10为例，下载好后解压文件，运行openrefine.exe，就可以看到运行的shell中间显示关于本地服务器的信息，接着在浏览器中打开localhost:3333就可以看到该程序的交互界面。 可能是我放置的文件位置不太对，需要以管理员权限运行才可以成功运行本地服务器。 我们已经明白了使用OpenRefine的目的是对数据进行初步处理，那么接下来的使用方法也就会针对目的重点说明。 数据导入 初始页面左边有几个选项，依次是新建/打开/导入项目和语言设定，英语不好的推荐先在语言设定里面把语言设置为中文，然后在新建项目里面可以选择以本地文件/URL/剪切板等多中方式载入文件，上面的介绍里面我们可以看到原生的OpenRefine就已经支持相当多的文件格式，比如JSON，XML， CSV等等主流格式，这在某种程度上告诉了我们以后获取文件可以暂且先把文件保存为这几种格式。 选择文件以后会进入新建项目界面，上面我们已经提到过，OpenRefine的工作模式是一张表一个项目，我们现在可以看到这张表的初步样子，同时可以在配置里面调整字符编码和一些文件载入属性，保证文件载入正确。 确认没啥问题的话就径直新建项目吧。 数据选择 首先要明白OpenRefine操作的数据一般都很大，手动一行行基本是行不通的，因而，基本工作思路是先选择上需要修改的对象，然后一并修改，这个过程非常类似于关系型数据库中对表格操作。OpenRefine提供了两种方法，分别是归类和文本过滤器。 归类大概就是对一列的分类，通过分类来筛选不同类别，最基本的有根据文本内容/数值大小/时间/函数分布等等，这里重点讲一下自定义归类，接触一下OpenRefine的自定义方法。 在自定义归类里面的语言上选择python / Jython，最终的数值就是return的值，姑且可以当作一个小处理程序，系统给定了一些基本且简单的数据接口函数和函数，具体可以参考界面中的帮助。既然可以使用python那么我们自然可以使用函数，列表生成式，甚至应该连类都是可以用的，如下简单的实验了下，请注意实验中关于缩进，一格空格即可，看来再也不用游标卡尺了（滑稽 def f(x): return x; return \"\".join([f(x) for x in value]); 至于正则表达式就没什么好说的了，从零开始30分钟入门教程可以帮到第一次接触这个读起来有点反人类的东西，如此反人类还这么多人就可见这个东西在匹配文本上有多实用。 数据更新 更新的对象就单个单元格，列，和行来讲。 对于单个单元格，单纯修改它可能是最方便的方法，毕竟单个。 对于列，OpenRefine为我们提供了强大的转化功能，不过请注意选单在edit cell也就是编辑单元格里面，和上面的归类类似，有很多系统自定好的常用转化可以用，当然也可以自定义转化。 在edit column也就是编辑列选单里面则是更像是对列而不是列里面的数据的操作，除了修改列名/删除该列以外，还可以通过此列派生出新的列，不过自定义表达式里面是可以访问到其他列的，也就是说需要新列的时候我们随便找个列派生其实就可以了。 对于行，似乎只看到有加星标加旗子，和删除所有匹配行的选项。 数据删除 关于删除的方法在上面都有提到，这里再说一次是为了重申OpenRefine的数据洗白功能，所谓洗白也就是去掉无用的冗杂数据，在大数据时代，去除冗杂数据，精炼有效分析对象自然是很重要的，去除数据的标准自然是方案特意的，就不再啰嗦了。 数据导出 完成上述步骤我们也就完成了对数据的初步加工，接下将成果导出就好了，如果之前的操作有失误的地方也可以UNDO撤销，导出格式可以是CSV，Excel和HTML table等。 关于实验留下的问题 实验过程可以参考上述使用说明，这里就不提供截图什么的证明了 举例说明正则表达式。 # 两个匹配邮箱的正则表达式 \\w+@\\w+\\.\\w+ 正则表达式的作用有哪些？ 从日常使用中我们可以知道，正则表达式的作用是通过字符串来描述，匹配一些列符合某个规则的字符串，方便我们搜索，替换匹配到的文本 通过操作，举例说明OpenRefine 中正则表达式的应用。 举一个简单的例子，在包含数字的的一列使用文本过滤器，选中正则表达式，输入^\\d2$就可以匹配到该列只含有两位数数字的选中行。或是通过^\\d+$匹配到只含大于一位的数字的行。 探索OpenRefine 更多数据处理功能。 可以参考上文使用Jython的部分。 参考 Java Regex OpenRefine Wiki OpenRefine DOCS OpenRefine Jython "},"4.软件工具/SVN 版本管理工具.html":{"url":"4.软件工具/SVN 版本管理工具.html","title":"SVN 版本管理工具","keywords":"","body":"本文将带你快速上手SVN，我们希望您有基本的学习能力，最好有过一些编程经验。 SVN 版本管理工具 jskyzero 2018/05/20 概念介绍 什么是SVN 通俗的来讲，SVN是一个版本管理系统(version control system, VCS)。 我们经常使用的另一个版本管理工具——Git，SVN干的就和Git干的事情差不多。 SVN与Git的区别 除了用来干的事情的目的类似以外，其他基本没什么相同。 其实从用户角度工作的流程也是很类似的。 其他的相同和不同，或者说优点和缺点建议自行把握。 SVN（和Git）的优缺点 参考上个问题最后一点。 聊完了SVN我们来聊一下通用的一些概念。 Repository：这个单词似乎直接理解起来是仓库一类的意思，这里就是指源代码存放的地方。 Checkout：第一次发现这个词原来是提取的意思，如果使用过Git的话对这个单词应该不会陌生。 ... Learn by Doing 下载和安装就不再赘述，Windows的话记得检查二进制执行文件的路径是否添加到了系统Path上。 初始化一个仓库 假设当前路径为D:\\SVN\\： # 新建文件夹 mkdir hello # 初始化 svnadmin.exe create hello 接下来对于目的仓库的引用，我们将采用文件路径的形式，而不再对SVN或者HTTP等需要配置的进一步的展开。 提取并开始工作 # 新建目录1 mkdir 1 # 新建目录2 mkdir 2 # 提取文件副本到目录1 # 关于 file:///D:\\SVN\\hello # 这个就是那啥我们上面说的以文件夹的形式引用仓库 svn chekcout file:///D:\\SVN\\hello 1 # 提取文件副本到目录2 svn chekcout file:///D:\\SVN\\hello 2 # 创建新的文件夹 cd 1 mkdir branches mkdir trunk mkdir tags # 查看当前状态 svn status # 添加文件夹 svn add * # 再次查看当前状态 svn status # 提交 svn commit -m \"initial hello proj structure\" # 更新2 cd ../2 svn update # 此时我们可以看到已经可以取下来新建的文件夹。 处理冲突 那我们来手动自己制造一点冲突： # 制造比对对象 cd ../1/trunk echo \"hello world!\" >> hello.txt # 提交 svn add hello.txt svn commit -m \"add hello.txt\" # 制造冲突 cd ../../2/trunk # 冲突出现 echo \"hello world!!\" >> hello.txt svn add hello.txt svn commit -m \"this will fail\" # 解决冲突 svn update # ... # 具体的解决方法有很多，命令行交互中也提供基本的MENU里面很多选项，这里不再废话 工作流程 这个是svn-book中推荐的work cycle，其实和git的是类似的。 更新当前副本，svn update了解一下。 更改工作，可能大部分时间都在这里。 检查更改，svn status等指令查看修改内容。 改正错误，如果有错误。有丢弃修改的指令，建议svn help看一下。 提交修改，当然，如果此时又冲突的话，要处理冲突。 总体来说，对于任何版本管理工具这套思维模式都是不错的。 补充，关于github与svn 请参考Support for Subversion clients。 实际上试了下因为是一直是git sync的思维所以用起来多少还是有点问题，不过还可以凑合。 如果是练手或者目录不复杂的可以试试看。 更深的地方 物尽其用 我们之间建了几个文件夹，这些文件夹其实都是有通用默许的推荐的使用方法的。 SVN对于分支的管理方式，合并，等等是怎样的流程。 SVN的Tag又是干什么的。 当文件传输意外终端，应该怎么办？ 怎样对文件加锁？ 等等，类似这样的问题，如果像我一样懒的话，当然是等到用到的时候再说。 实现背后 我们可以打开最开始创建的那个文件夹，仔细分析一波里面的组织结构和内容，SVN背后是怎样储存文件的呢？ 参考 伪装是SVN官网的超链接 伪装是SVN官网文档中的某本小参考书 ... "},"4.软件工具/Shell 常用脚本和指令.html":{"url":"4.软件工具/Shell 常用脚本和指令.html","title":"Shell 常用脚本和指令","keywords":"","body":"本文汇总记录一些各个平台上的常用脚本和指令 Shell # 反向连接文件到一个 for i in $(ls -r); do cat $i >> new.md; done; # 将.png结尾的文件名改为 .jpg ls | cut -d '.' -f 1 | xargs -I {1} mv {1}.png {1}.jpg for x in *.jpeg; do mv \"$x\" \"${x%.jpeg}.jpg\"; done Poweshell $PWD = Get-Location Write-Output \"Rove dll\" Remove-Item *.dll Write-Output \"Build Dll\" csc /t:library .\\JskyLib.cs vbc /t:library .\\JskyLib-vb.vb [Reflection.Assembly]::LoadFile(\"$PWD\\JskyLib.dll\") [Reflection.Assembly]::LoadFile(\"$PWD\\JskyLib-vb.dll\") Write-Output \"Using JskyLib.Math\" [System.Console]::Write(\"`n`n1 + 2 = \") [JskyLib.Math]::Sum(1, 2) Write-Output \"Using JskyLibVB.MathVB\" [System.Console]::Write(\"`n`nPrint Version Message`n\") [JskyLibVB.MathVB]::Version() Windows常用指令 OneDrive 删除注册表 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\NameSpace Create Big File (50MB) fsutil file createnew test.txt 52428800 Create Big File (5GB) [System.IO.Path]::GetTempFileName() | % { [System.IO.File]::Create($_).SetLength(5gb).Close;$_ } | ? { $_ } nvidia experience 下载目录 C:\\ProgramData\\NVIDIA Corporation\\Downloader Powershll prompt notepad $PROFILE function prompt {\"~: \"} function prompt { \"PS \" + $( Get-Location | split-path -leaf ) + \": \" } WSL wsl --shutdown wsl --export wsl --import [Options] wsl --distribution, -d wsl --set-default, -s # \\HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Lxss DefaultUid Dec 1000 Linux apt proxysudo nano /etc/apt/apt.conf Acquire::http::Proxy \"http://:@192.168.199.229:7890\"; Acquire::https::Proxy \"http://:@192.168.199.229:7890\"; gem install proxysudo gem install -p http://127.0.0.1:7890 github-linguist Python 水平速度、落地夹角已知，求下落速度math.tan(math.radians(10)) ImageMagick sudo apt install imagemagick sudo vi /etc/ImageMagick-6/policy.xml convert *.png -quality 90 *.jpg convert *.jpg mydoc.pdf ffmpeg 合并视频&音频ffmpeg -i video.mp4 -i audio.wav -c copy output.mkv Cut# from to ffmpeg -i input.mp4 -ss 00:05:10 -to 00:15:30 -c:v copy -c:a copy output2.mp4 # duration ffmpeg -i input.mp4 -ss 00:05:20 -t 00:10:00 -c:v copy -c:a copy output1.mp4 draw.io config for image size { \"maxImageSize\": \"10000\", \"maxImageBytes\": \"30000000\" } "},"4.软件工具/VsDevCmd 在Shell中的打开姿势.html":{"url":"4.软件工具/VsDevCmd 在Shell中的打开姿势.html","title":"VsDevCmd 在Shell中的打开姿势","keywords":"","body":"想在PowerShell中直接用VsDevCmd还是需要点折腾的，本文将以使用VsDevCmd为例带读者初步学习编写.bat VsDevCmd 在Shell中的打开姿势 jskyzero 2017/05/31 看完本文，您将可以在PowerShell自定义运行Visual Studio 2017 的VsDevCmd.bat，在命令行编译/调试的时候还是挺方便的。 简介VsDevCmd 我是在想在PowerShell中直接运行csc编译.cs文件的时候引起的这个需求，嗯我们可以在开始菜单的Visual Studio 2017文件夹中找到Developer Command Prompt for VS 2017，这个东西就提供给我们的工具了，不过直接运行系统的话会有三个问题，其一是运行方法是鼠标点击，这显然不够效率，其二是自带的运行的话是在CMD里面的，讲波道理ls指令都没有的话还是用不太顺手，其三是运行时候的目录会变成源文件的根目录里，需要我们手动再导航，这就比较尴尬。 初步尝试 我们可以定位下开始菜单里面的快捷方式，来看看这玩意具体是啥。 在快捷方式的目标里面就写的是 %comspec% /k \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\Common7\\Tools\\VsDevCmd.bat\"，欸这样我们就找到了源文件VsDevCmd.bat的地址，那么初步来看我们有两种解决方法。 直接添加源文件所在路径到Path 这个想法简单粗暴，实际上也比较实际，基本等同与直接运行.bat文件，大概等效与运行如下.PS1文件： cd \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\Common7\\Tools\\\" .\\VsDevCmd.bat 除了暂时没找到回到上一次目录的方法，其他都还挺好的，查到的一些除了像这样写function的 function cd { if ($args[0] -eq '-') { $pwd=$OLDPWD; } else { $pwd=$args[0]; } $tmp=pwd; if ($pwd) { Set-Location $pwd; } Set-Variable -Name OLDPWD -Value $tmp -Scope global; } Get-Item function:cd 就是这样直接回去的 cd $OLDPWD 不过在我这里用起来就会报关于path的错误。 修改快捷方式指令加入PowerShell 这个的想法就是我们修改原先快捷方式的指令，来达到使用PowerShell的目的，比如来说修改成%comspec% /k \"\"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\Common7\\Tools\\VsDevCmd.bat\" & powershell\"，嗯这个也是最好能回到原先目录就好了。 新建.bat文件 因为是自己新建，当然可以建到已经Path有的路径，第一个版本是模仿快捷方式写的，如下：%comspec% /k \"\"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\Common7\\Tools\\VsDevCmd.bat\" & powershell \"然后我们加上返回上一层就好了：%comspec% /k \"\"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\Common7\\Tools\\VsDevCmd.bat\" & cd %CD% & powershell \"完美解决这个问题了。 不过如果是完全自己新建的话，记得把当前路径加入到Path中。 参考 What does “&&” in this batch file? Using Visual Studio Developer Command Prompt With PowerShell Managing Current Location "},"4.软件工具/gitmoji 让你的提交日志更可读.html":{"url":"4.软件工具/gitmoji 让你的提交日志更可读.html","title":"Gitmoji 让你的提交日志更可读","keywords":"","body":"gitmoji给你的git提交信息提供了一个分类和装饰的作用，本文将整理一些平时会经常使用的表情。 gitmoji 让你的提交日志更可读 jskyzero 2020/08/01 为什么要使用gitmoji 首先，git commit信息如果没有专门的约束和规范的话，很容易写上一些毫无意义的内容，最后就不方便管理，gitmoji提供了一种实用的分类方式，大多数你的修改都可以落到已有的修改类型上。 其次，大部分情况，git message都是纯粹的文本，直观上需要理解文本内容才能明白提交的修改内容，而使用gitmoji则可以直观的从图标上理解，嘛，能简化理解本身就是一件好事。 如何使用gitmoji 很简单，在提交的时候在开头（为什么是开头，其实在任何不影响解析的地方理论上都是可以的，不过考虑到人类的阅读习惯，在开口放上重要的信息似乎没什么不对。）加上特定的字符串就好啦。 如果你使用一些命令行的工具查看提交日志，一般还是以字符形式展现的，但是如果你是使用一些支持字符表情的方式，就可以看到你的gitmoji被翻译成了形象具体的图标。 就咱的跨平台使用来讲，被翻译成不同的图标是常有的事情，不过还是图案的含义还是没有改变的。 常用的moji 项目流程 初始化，:tada:，Initial commit. 发版本，:bookmark:，Releasing / Version tags. 升级依赖，:arrow_up:，Upgrading dependencies. 日常开发 施工中，:construction:，Work in progress. 新特性，:sparkles:，Introducing new features. 写文档，:pencil:，Writing docs. 修bug，:bug:，Fixing a bug. 删文件，:fire:，Removing code or files. 写垃圾，:poop:，Writing bad code that needs to be improved. 符合规则，:ok_hand:，Updating code due to code review changes. 更新资源，:bento:，Adding or updating assets. 让项目变得更好 艺术，:art:，Improving structure / format of the code. 提速，:zap:，Improving performance. 写注释，:bulb:，Documenting source code. 陶醉，:beers:，Writing code drunkenly. 陶醉 / :beers: 希望这些有趣的小东西可以让你更加喜欢上编程w Reference gitmoji github gitmoji "},"专题-UNITY/extend_editor.basic.html":{"url":"专题-UNITY/extend_editor.basic.html","title":"Extend Editor.Basic","keywords":"","body":"唔，稍微聊一下unity中扩展编辑器的相关内容。 UNITY：擴展編輯器 前置问题 为什么要用unity 基本上，游戏开发大概用啥都可以，能做出想要的效果就好，用unity大概只是因为unity有一些其他引擎没有的优点。 比如相对而言对“小白”更友好，更符合直观逻辑等，不过可能主要还是最近工作使用的是Unity引擎，毕竟屁股决定脑袋。 但是对于一个入门的新人来讲，不总是需要挑一个来用用看的吗，所以选Unity也还不错。 为什么要扩展编辑器 首先，并不是所有人的计算机科班出生，有编程基础，可能对于从事设计的同学来讲，去了解底层代码的运作是代价很大的，去亲自编写逻辑代码，生产和维护是成本昂贵的。 所以会有专门的程序来做一些脚手架或者中间层之类的东西，为策划提供出编辑上的接口，来简化修改这个过程。 接下来我们就来正式的聊聊如何扩展Unity的编辑器。 正文部分 当然如果需要详细且细致step by step的过程介绍，可以看参考里面的一些介绍，总体来看我们可以定义Unity编辑器对一些数据在Inspector的渲染过程，也可以自己新建一个窗口。 ImGUI概述 咱也算是写过诸如Web，UWP等等等UI系统的，然后Unity里面的这套管叫ImGUI，名字的意识大概是立即UI，是给个返回值的那套UI，所以我们要记得最后把值赋值回去。 扩展Inspector Inspector上是可以显示附上的代码的一些public字段的，对于一些复杂的数据类型的实例，或者对于一些我们希望自定义渲染行为的数据，还是有方法可以自定义他的渲染过程的。 大概的思路是实现一个继承于PropertyDrawer的渲染特定数据类型的实例，并重写函数实现对应的渲染过程，贴个例子代码： // custion serializable class [Serializable] public class Ingredient { public string name; public int amount = 1; public IngredientUnit unit; } // IngredientDrawer [CustomPropertyDrawer(typeof(Ingredient))] public class IngredientDrawer : PropertyDrawer { // Draw the propery inside the given rect public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) { // Using BeginProperty / EndProperty on the parent property means that // prefab override logic works on the entire property. EditorGUI.BeginProperty(position, label, property); // Draw label position = EditorGUI.PrefixLabel(position, GUIUtility.GetControlID(FocusType.Passive), label); // Don't make child fields be indented var indent = EditorGUI.indentLevel; EditorGUI.indentLevel = 0; // Calculate rects var amountRect = new Rect(position.x, position.y, 30, position.height); var unitRect = new Rect(position.x + 35, position.y, 50, position.height); var nameRect = new Rect(position.x + 90, position.y, position.width - 90, position.height); // Draw fields - pass GUIContent.none to each so they can draw with labels EditorGUI.PropertyField(amountRect, property.FindPropertyRelative(\"amount\"), GUIContent.none); EditorGUI.PropertyField(unitRect, property.FindPropertyRelative(\"unit\"), GUIContent.none); EditorGUI.PropertyField(nameRect, property.FindPropertyRelative(\"name\"), GUIContent.none); // Set indent back to what is was EditorGUI.indentLevel = indent; EditorGUI.EndProperty(); } } 扩展新窗体 这个就也很简单了，大概是写个渲染函数留个入口就可以了。 // Add menu item named \"My Window\" to the Window menu [MenuItem(\"Jsky/HelloWorld\")] public static void ShowWindow() { //Show existing window instance. If one doesn't exist, make one. EditorWindow.GetWindow(typeof(HelloWindow)); } void OnGUI() { GUILayout.Label(\"Hello\", EditorStyles.boldLabel); myString = EditorGUILayout.TextField(\"Text Field\", myString); groupEnabled = EditorGUILayout.BeginToggleGroup(\"Optional Settings\", groupEnabled); myBool = EditorGUILayout.Toggle(\"Toggle\", myBool); myFloat = EditorGUILayout.Slider(\"Slider\", myFloat, -3, 3); EditorGUILayout.EndToggleGroup(); } 虽然具体选择上有点讲究，以及在基础的内容往上可以做的事情还很多，但是这里就写到这里好了。 参考 full example: extend-editor ExtendingTheEditor Immediate Mode GUI (IMGUI) ... "},"专题-UNITY/mvc-in-unity.html":{"url":"专题-UNITY/mvc-in-unity.html","title":"Mvc In Unity","keywords":"","body":"本文我們簡單聊一下，游戲開發中的MVC架構。 遊戲中的MVC架構 預告 本文包含以下內容： 一種MVC在遊戲開發中的可能的例子。 該例子的完全實現細節和可能踩坑。 C#高階語法（含高階繼承、反射、委託等）。 本文適合以下群眾閱讀： 對遊戲開發感興趣的人 有C#使用基礎（、UNITY引擎經驗）的人 已經接觸過MVC（Model-View-Controller）框架的人。 本文不適合以下群眾閱讀： 網絡噴子 完全不懂編程的人 正文 以下開始正式的內容，先簡單介紹概念，然後介紹實現，最後做一個總結。 概念介紹 沒想到吧，游戲開發中也有MVC，大概的思路是分開Model管理數據，View管理引用，Controller管理邏輯。 傳統的MVC框架 先聊聊傳統的MVC框架吧，傳統的MVC框架是 Model：與儲存數據 Controller：管理數據的操作 View：管理數據展示相關的操作 可能如果完全沒有開發經驗的話（其實不適合閱讀本文，本文對你收益不大，建議繼續閱讀前及時補充相應知識和經驗。），不太理解為什麼我們要拆分開來，這些框架究竟是幹什麼的？ 這裡的框架是用來約束你的行為的，讓你能快速理解你在做什麼，你可能會覺得我為什麼會不知道為什麼我會迷離？你可能現在不會迷離，但是假如時間上經過一年、五年、十年呢？如果你需要管理大量系統邏輯和對應的底層實現呢？如果你是在別人的基礎上開展工作呢？你要重寫嗎？ 軟件開發已經脫離了個人時代，進入了團隊合作的時代。框架是可以用來指導開發者的行為，降低群體間合作的成本的，一方面可以互相劃分工作，另一方面可以降低理解門檻。在初期時期，你可能寫過幾百上千行的main函數，後來你就會明白要分函數，要抽象邏輯，函數之間可以互相組合達到更大的表達力，這就是另一個問題了2333。另一方面，你可以劃分文件，讓一切都是“可管理”的，普通人能同時管理的物體數目似乎就是7-13（憑印象，取自代碼大全），因而做合理的劃分是十分有必要的。 你可能無法提出一些框架，大部分人實際上也不需要提出，我們能從根本目的理解框架的目的、按規則去使用，如此就可以了。 讓少數天才的工作為更多人服務，不是很棒嗎？ 遊戲中的MVC框架 在JohnDoeWorld的開發時期，已經初步理解到隨著設計上的希望擴充，底層代碼量的狂野生長，當時主要采用單例模式，盡可能的將方法的使用抽象出來，即便如此，還是沒能分出更多的精力去把表現層次上的問題修復。 在不久之前的Project.DL，因爲是一個人業餘在做，基本上已經被折騰到了極限，感覺各種東西都混到一起，只有實現當時能理清究竟什麽是幹什麽的，事後多半就變成一鍋粥（其實...這是個通用的問題） Memento項目初期，從開發那裏接觸到了游戲開發中的MVC這一説，試著去翻了一下實現，然後自己獨立於UNITY引擎用新的.Net Core 3.0給實現了一番，這也就是這篇文章的由來了。 擧一些具體的例子來講吧，如果你使用Unity開發，你是需要操控游戲中的具體物體的，於是你多半需要存儲一個引用——不管是靜態的賦值、還是動態的搜索，而這個關聯，我們就可以放在View層，對應之前的和界面相關的内容。 Model層依然存儲數據，不過這裏的數據就是獨立於游戲物體的更加抽象的數據了，Controller層就儲存對數據的操作。 實現相關 可以參考MVC.DotNet。 從具體的代碼一層層開始談起吧。 Model-View-Controller Model: 普通類（結構體） View: 繼承Behavior，視遊戲引擎接口而定 Controller: 對應具體Model View，且保存其引用； 繼承Caller允許根據Command類型調用不同Command Command-Caller-Core Command：虛函數GetController Caller：繼承Behavior，含通用的調用Command方法Call，實現交由Core部分處理 Core：核心部分 保存所有View、Model、Controller、Command對應邏輯，使用Dict，用Type做Key 對於Command調用，首先拿到Controller 第一次使用，如果不存在，則去創造 然後使用反射找到OnCommand邏輯 提供通過字符名直接反射找到方法 Exception, etc. Exception，外圍異常類，放置需要額外操作。 語法細節 建議直接閱讀源碼和MSDN相關參考，這裡不展開來說了。 "},"专题-UNITY/unity.html":{"url":"专题-UNITY/unity.html","title":"Unity","keywords":"","body":"本文將記錄Unity官網的教程中需要注意的部分，并附上總結。 UNITY：速览 教程 似乎是有14個，想過一遍大概也很快。 1.Interactive Tutorials Play & Edit Mode 學會進入遊戲和編輯模式。遊戲模式中對場景做的任何修改都是不會保留的。 Game Objects & Components 教我們如何給遊戲物體添加剛體組件來添加物理行為。 Tweaking Components 教我們調整組件的值來使得行為符合預期。 Prefabs Power 教我們使用預設。 2.Roll-a-ball Tutorial Introduction 概述遊戲的組成，以及接下來教程的涉及方面。 Environment and Player 建立遊戲內的環境以及讓人物移動。 Camera and Play Area 簡單的攝像機跟隨以及設置遊玩區域。 Collection, Scoring and Building the game 設置可回收物體並且添加UI，完成遊戲。 3.2D Game Kit Getting Started 大概只是一些速覽的部分。2D遊戲中常用的一些手段。 ... 4.3D Game Kit 唔可以調整下優先級最後再管這些Kit類的教程 5.Space Shooter tutorial Introduction 一個簡單的3D射擊小遊戲。 Game setup, Player and Camera 添加玩家，攝像機，光源。 Boundaries, Hazards, and Enemies Scoring, Finishing, and building the game Extending Space Shooter 6.Survival Shooter tutorial 7.UFO tutorial 8.Space Chicken 9.Tanks tutorial 10.Adventure Game tutorial 11.2D Roguelike tutorial 12.Tower Defense Template 13.Creating Beliveable Visuals 14.Procedural Cave Generation tutorial 手冊 Unity User Manual Working in Unity Importing 2D Graphics Scripting Multiplayer and Networking Audio Animation TimeLine UI Navigation and Pathfinding Unity Services XR Open-source repositories Asset Store Publishing Platform-spcific Experimental Legacy Topic Best practice guides Expert guides New in Unity Packages Documentation Glossary 參考 UnityEngine UnityEditor Unity Other Reference Unity Learn Tutorials Unity User Manual Unity Scripting Reference "},"专题-UNITY/扩展-游戏设计.html":{"url":"专题-UNITY/扩展-游戏设计.html","title":"扩展 游戏设计","keywords":"","body":"咱想做游戏的初衷是制造欢乐,传播感动.然后这是Tencent互动娱乐的一个公开课,陆陆续续也上了好几节课,现在把内容整理一下. 扩展-游戏设计 jskyzero 2017/11/05 游戏概览 游戏源于娱乐,娱乐源于生产过剩. 游戏产业链(开发商/运营商/宣传/等等) 游戏团队的分工(策划/美术/程序/运维/等等) 体验设计 不同的视角(玩家/策划) 观察细节,怎样做的更好. 设计一个游泳馆.目标用户/体验(增值)/特色系统 => 设计的类比. 杀人游戏的优点/缺点,内部系统的组合. 数值设计 什么是游戏中的数值? 感性世界的具象化 成长体验的体现 游戏幕后的因素 游戏数值设计的要点: 控制玩家成长节奏 不要使用过于复杂的公式和算法. 要注意设计背后要达到的目的. 搭建体验模型. 学习现有游戏数值现状,反推游戏设定. 系统策划 系统是规则的集合. 放大游戏中的核心体验. 策划->功能(需要资源)->测试->发布 提升:改善游戏细节/没有绝对的创新 世界观和IP 世界观 系统数值-> 游戏的体验. 世界观-> 游戏的上限. 广义上:增强角色代入感/完善社会人文体系/游戏中或多个文化依据. 狭义上:特定游戏/资源需求/文学包装. 事件出现在时间/空间坐标系中的某点. 设计总纲:背景/地理/种族/物品/装备/人文/政治体系. 侧重点人物个体/人物和人物之间的关系. IP:知识产权 考虑前提: 时间(沉淀/重要时间节点) 成本(人群收益/改变难度/玩法契合) 地域(日系IP/中国IP)=>和厂商间的沟通方式 真实感/可塑性/人物设定/商业化难度 => 收益 游戏运营 游戏研发人员的分类 系统策划：系统/数值/关卡/文案 运营策划：商业化/赛事运营/版本管理/活动策划/市场推广/数据分析/用户管理 游戏开发：前端开发/后端开发 游戏美术：3D组/2D组 测试 游戏研发的过程 研发：版权/MSDK/完善商业化内容/完善自有渠道 封测：优化商业化/游戏数据/制定运营策略/策划品牌宣传 公测： 运营： 什么是游戏运营？ Come Stay Pay 市场推广，引爆点，宣传媒介，泛娱乐。 活动目的，依然是吸引/留存/付费 版本管理，和其他方面所有人打好交道。 渠道合作，妹子(✿◕‿◕✿)。 需要品质 执行力高 抵制诱惑 关卡设计 你理解中的游戏关卡 主角/对手/环境/能力评价 什么是好玩的游戏关卡 游戏关卡是游戏的部分，为好玩的游戏服务。 代入感强/难度适中 人生入戏，戏如人生。 为什么感觉关卡厉害？ 符合游戏逻辑表现。 张弛有度的游戏节奏。 超出预期的感官刺激。 为什么感觉自己厉害 因为正反馈 怎样去做一个关卡 关卡定位 制作背景 设计制作 验证通过 反思积累 关卡在前期中期后期的不同表现 背景和成本估算 确认团队背景 估算开发成本 实际开始 引导/体验/进阶体验/奖励 场景，背景区和功能区的不同和融合 对手的强度的设计，表现和进阶 验证通过 怎样做一个好的关卡策划 执行力/审美/沟通/思维（设计全程都要有好的逻辑） Moba游戏 历史 原型：Aeon of Strife / 3C 作战主体围绕英雄 / DOTA 细分完善 每款产品都有独特的体验，共性/差异在哪里？ 什么是MOBA Multiple online battle arena 体验报告，将体验聚合 角色扮演/成长/合作/对抗 MDA Mechanics 规则：简单重要驱动力 Dynamics 设计：多样化交互层面向玩家 Aesthetics 乐趣：八大基本乐趣 感官/幻想/（叙事）/挑战/伙伴/（探索）/表达/投入 特定组合，产生特定的游戏。 几款moba游戏的异同 在乐趣上的硬核程度不同。 对概念的理解不一样。 对角色扮演（英雄）/成长/合作/对抗的理解和侧重导致了不同的系统。 作战博弈，作战半径，把你拉进我的优势范围，而我不进入你的范围。 项目实例分享 一个英雄的诞生 策划文档：角色设计世界观/打法定位/核心体验/技能组 美术设计：原画设计/模型/动作/特效 技能实现：技能逻辑/美术资源整合/策划配置预留 参数调整：手感参数调整/战斗参数调整/表现参数调整。 台面之下是扎实的基本功 腾讯游戏分析，以数据说话。 70%的信息收集 29%的分析 1%的创意 100%的热情和耐心 动作游戏 发展历史 雏形/操作要素/平台/横板。 核心已经确定，只能细化玩法。 继承原来规则，继承和调整，形成自己预期有个性的产品。 什么是动作游戏？ 以动作为表现重点（广义） FTG 两个角色一对一决斗的游戏 平衡/公平/最大化的将玩家注意力集中到动作中的乐趣来。 同样的HP/攻击力。 无偏斜的场地和初始站位。 一致的技能使用规则。 博弈是怎样产生的？ ACT 丰富的机关玩法 具有挑战性的敌人 更广阔的行走区域 对比 战斗的基本概念和名词 双方的时间/位移 帧：时间单位，画面/逻辑刷新 攻击：待机/起手/攻击/收招 受击：待机/受击/恢复 帧数表：在时间性能上的精确统计和直观反映。 卖数值的ACT，将持续帧当数值来卖。 目押：老虎机。 取消：打断，在任意阶段取消后摇。 攻击受击方的位移。 确认（连击的）难度，和位移/浮空有关。 攻击受击框 动作层面转移图 异常状态 制作一个角色 人物设定/模型动作/2D抽帧/基础动作制作/技能特效制作/完整技能制作/操作与打击感调整/完成输出 立回：为了攻击/防御而进行的一系列动作 先手/后手/距离牵制/诱导攻击 配置，特效/攻受击框 打击感：命中以后反馈以后刺激快感 关键帧，重点表达，停留时间较长。 动作做到位，关键帧做好看，动作要足够舒展。 注意角度/衣服造成的形体重叠。 加上视觉残留，帧特效，拉大器官/异化造型，衣服的自然飘动 关键阶段分配更多展示空间，让玩家把动作和过程看清。 特效/音效 优化 受到攻击的特效：制造刺激，快/塑造形体，慢 攻击/受到攻击双方的语音使用，双方/武器 判定的设计 大小/位置，不同动作受击框尽量一致。 特殊效果 打击顿帧，停顿表示阻力感 镜头震动，动作游戏标准配置。 没有最正确，只有更加合适。 FPS游戏设计入门 课还是分享，一些知识的分享。 定义 动作游戏分支/游戏角色（Avatar）的视角/使用机械或者投掷武器进行战斗 移动（Navigation，巡航）/瞄准（Observation）/射击（Shooting） 光枪游戏/模拟游戏/TPS 历史与发展，两大类别。 最早的射击游戏，点阵图，人类对射击和远距离攻击的原始欲望。 1992年重返德军总部/1993年DOOM/半条命引擎开源 成为第九艺术，未来仍然是不可测，技术的更新迭代会导致发展。 两大类别：超级系/正式系 基础系统设计 元素，机制，系统，游戏 枪械基础 role: avatar + camera + weapon hit scan, ray shot / projectile, real 武器属性 游戏性的定位，适用性和游戏策略。（设计从体验出发，从定位开始） 详细的功能属性：基本伤害/射程/弹药容量/换弹机制/精准（散射/后座力）/行动影响/伤害影响 真实，ADS，东西只有做的好，玩家才会认可。 表现原理 武器模型/视角表现：武器的指向性。 HUD表现：多少参数应该给玩家，准星设计表现武器类型。 反馈表现：受击表现，命中表现。 系统：图形化信息，脑：操作 操作属性 + 表现反馈 = 手感，符合定位，符合预期，准确，快速。 PVP游戏模式和关卡设计 单人游戏，SP/传统PVE模式，传统ACT闯关游戏的一个分支。 剧情/主线/支线/过场/事件和逻辑 关卡：空间/目标/路径/挑战，园陵和公园设计 多人游戏 单局模式：胜负规则：手段/冲突点：战术/目标机制：逻辑/复活机制：节奏 举例：团队死亡竞技，占领据点竞技，绝地求生：缩圈 关卡设计：核心在于驱动，怎么让玩家动起来。 功能层/表现层 区域规划：功能/连接/尺寸/核心交战距离/玩家移动属性 动线设计：玩家成本较低的运动趋势， 关键点：汇合点，优势阵地的必经之路，目标阵地 绝对镜面/优势对等/动态平衡 体验 枪械/表现/模式/关卡。 发展方向：自由度，写实。 需要，就去做。 移动端的体验，很多问题，比如输入，降维，辅助瞄准，现阶段做的还不够好。 移动端，移动巡航射击，三个输入，两个手指，降维要怎么降？额外输入，重力感应。 策略是一切游戏的核心，玩游戏是消耗内容，无限重玩的可能性。偏向竞技，固定是可以训练的。更深的单局体验。 结业典礼： 展示PowerPoint / 游戏Demo（四部以上的展示机） 介绍游戏名称/小组/核心玩法/卖点/技术美术解决/畅想未来/心路历程 半个小时，PPT15分钟 附录 常见游戏类型简称 ACT：动作游戏(Action Game) 强调玩家的反应能力和手眼的配合。动作游戏的剧情一般比较简单，主要是通过熟悉操作技巧就可以进行游戏。 AVG：冒险游戏(Adventure Game) 取玩家输入或选择指令以改变行动的形式。强调故事线索的发掘及故事剧情，主要考验玩家的观察力和分析能力。 有时候很像角色扮演游戏，但不同的是，冒险游戏中玩家操控的游戏主角本身的等级、属性能力一般是固定不变并且不会影响游戏的进程。 A-AVG: 动作冒险游戏(Action-Adventure Game) 是冒险游戏的分支，它融合了动作游戏的一些特征。 除了需要探索找到游戏过关的关键物品，通过各种各样的险要的地形之外，还可能需要与游戏中的其他角色进行战斗。 ARPG：动作角色扮演游戏(Action Role-Playing Game) 意指将动作游戏、角色扮演游戏（RPG）和冒险游戏的要素合并的作品。 基本型是具备使角色成长继续冒险的RPG要素、对于战斗场景的动作性处理（非选项式战术，考虑到操作时差等的处理）、解决隐藏谜题或机关的冒险游戏要素等。 Beat'em up：清版动作游戏 CTF：夺旗(Capture The Flag) CMS: 建造与经营模拟游戏 FPS：第一人称设计(First-person shooter) FTG：格斗游戏(Fighting Game) Galgame：美少女游戏 H&S：砍杀游戏 H-Game：日本成人游戏 MMOG：大型多人在线游戏 MMORPG：大型多人在线角色扮演游戏(Massively multiplayer online role-playing games) MUD：一款多人及时的虚拟世界，通常以文字描述为主 MUG：音乐游戏 RPG：角色扮演游戏(Role-Playing Game) 在游戏中，玩家扮演虚拟世界中的一个或者几个角色进行游戏，玩家通过操控游戏角色与敌人战斗，提升等级、收集装备和完成游戏设置的任务，并体验剧情。 通常这类游戏都是由玩家扮演角色在游戏世界中漫游，而一路上的各种遭遇（如战斗、交谈、会见重要人物等）则是玩家人物成长及游戏进行的重要关键所在。 SRPG：战略角色扮演游戏(Strategy Role-Playing Game) Shmup/STG：清版射击游戏(Shoot'em up / Shooting Game) SLG：模拟游戏(Simulation Game) TPS：第三人称射击游戏(Third-Person Shooter) RTS：及时战略游戏(Real-Time Strategy) Roguelike：类Rogue游戏，随机迷宫探索，回合制的方式。 "},"专题-UWP/async.html":{"url":"专题-UWP/async.html","title":"Async","keywords":"","body":"本文将讲述UWP应用中多线程的具体问题，将结合具体界面阻塞/后台线程访问UI线程问题同时给出具体解决方案。 UWP内的多线程 从第一次接触角度开始 可能最开始接触UWP的异步，是在使用C#的某些函数时候看到提示让我们添加await，然后又会提示我们修改函数为添加修饰async，从字面意思来讲，如果一个函数需要较长的执行时间，为了不阻塞应用的继续执行，一般是还是要提供UI的反馈的，那么我们就不能让程序卡在这里，这时候如果这个函数是async型的，程序就会另起一个线程来执行这个函数，如果这个函数需要返回数据，那么就用await来等待返回的值。 UI的阻塞 可能有同学不太能理解什么是UI的阻塞，举例来说。 我们随意给界面上加个东西 然后把这个虽然没什么意义但是很耗时间的东西放在页面的初始化里 int ans = 0; for (var i = 0; i 这样页面是需要很长时间才能加载完成的，我们是看不到“计算中”这样的输出的，这个例子还好，计算的时间可能会停留在加载界面，但是如果是界面上还有其他按钮，此时UI线程阻塞了，我们对其他按钮的事件的触发就会没有反馈。这自然不是我们想要的结果。 初步的尝试 那上面都说了有异步，那我把这个计算的环节写成异步函数不就好了吗？ async void CalAns() { int ans = 0; for (var i = 0; i 道理是这个道理，这样我们是能看到“计算中”的，但是很快计算结果出来的时候就会出错，报错的提示大概是使用了另一个线程的接口。 第一次遇见这个现象的时候我是很迷茫，现在看来也就是后台线程是不能直接访问UI线程的，进程之间的通讯是需要使用给定的接口的，如果我们非要访问，那可以使用Dispatcher，比如 async void CalAns() { int ans = 0; for (var i = 0; i { output.Text = ans.ToString(); }); } 嗯如果你没有上面的this怎么办？嗯这是个问题，可以考虑开个静态属性存下page，或者使用MVVM Light，MVVM Light也有给的解决方法。 如果我把值给返回回来 那你可以这么写 async void CalAnsAsync() { Func CalAnsFunc = () => { int ans = 0; for (var i = 0; i 用Task.Run()开新线程跑一个本来不是异步的函数，然后等待跑完把值返回来更新值。 参考 上面的大概只能起参考左右，如果有兴趣可以看下面的这些博文。 Windows 10 UWP开发：如何不让界面卡死 在MVVM中的多线程问题 "},"专题-UWP/mvvm_light.html":{"url":"专题-UWP/mvvm_light.html","title":"Mvvm Light","keywords":"","body":"嗯本文将结合具体代码帮助读者快速上手MvvmLight，我们希望读者已经了解Mvvm/DI/IoC的相关知识 MvvmLight快速上手 最近仍然在学习一些包的用法，这次分享关于MvvmLight的相关用法 关于Mvvm您需要知道 如果您是第一次接触Mvvm，请参考这篇文章，Mvvm的目的和具体方法在上面都有提及，在我们具体实现上，我们只需要注意逻辑分层，使用如上图合理的手段来联系层与层间就好了。 关于依赖注入和控制反转容器您需要知道 您可以参考这篇中文文章控制反转（IoC）与依赖注入（DI），我们说DI/IoC都是为了降低程序的耦合度，如果您对耦合度还没有感觉的话，可能是您代码写得太少，或者您使用某些编程技巧巧妙的避开了这个问题，不管怎样，能解决问题都是好的。 关于MvvmLight您需要知道 这里以这个系列的教程为叙述参考来说一下MvvmLight的主要功能 ViewModelBase && ObservableObject 嗯这个我们懂的，就是提供一个更新提醒的接口。 RaisePropertyChanged(() => Name); ViewModelLocator && SimpleIoc 嗯这个就是所谓的IoC容器了我们可以把ViewModel和Server在里面register，然后以后就可以直接getinstance了 ServiceLocator.SetLocatorProvider(() => SimpleIoc.Default); SimpleIoc.Default.Register(); RelayCommand 嗯这个就是和XAML绑定的Command了 如果XAML是事件怎么办？嗯你需要使用EventToCommand解决方法 如 说起来这个i可能需要额外装包呢。 Messenger 嗯这个就是最重要的消息机制的了，总之一个地方注册一个处理方法，然后就可以消息传递了。 Messenger.Default.Register(this, MessageToken.SendMessageToken, (msg) => { Msg = msg; }); // token 大概只是个确定特定接受方的字符串 Messenger.Default.Send(Msg, MessageToken.SendMessageToken); DispatcherHelper 嗯这个就是我们非UI线程与UI线程通信用的了，大概就是在app.cs里面初始化，然后在需要的时候调用接口就好。 DispatcherHelper.Initialize(); DispatcherHelper.CheckBeginInvokeOnUI(() => { Teacher.Students.Add(new Student() { Name = \"LaoLi\", Age = 25 }); }); 后记 就像在一开始说的，本文需要读者预先对一些知识有一定了解，MvvmLight提供了MVVM模式下编程的很多需要使用的模式/解决方案的封装，如果读者本身对MVVM了解就不够多，那么可能看起来就有点云里雾里。 "}}